<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Web Push Notification</title>
		<link rel="stylesheet" href="./styles.css">
	</head>
	<body>

		<div>
			<h1>Subscribete a un canal de notificaciones: </h1>
			<form onsubmit="return false;">
				<input type="text" name="userName" id="userName" />
				<select name="notificationChannel" id="notificationChannel">
					<option value="channel1" selected>channel1</option>
					<option value="channel2">channel2</option>
					<option value="channel3">channel3</option>
				</select>
				<input type="hidden"  id="FCMregistrationToken" name="FCMregistrationToken">
				<button id="subscribeButton"> Subscribe me! </button>
			</form>
		</div>

		<div>
			<h1>Envía una notificación</h1>
			<form onsubmit="return false;">
				<select name="usersListSelect" id="usersListSelect">
					<option value="everybody">Everybody</option>
					<option value="channel1" selected>channel1</option>
					<option value="channel2">channel2</option>
					<option value="channel3">channel3</option>
				</select>
				<input id="notificationTitle"	type="text" placeholder="notification title">
				<input id="notificationBody"	type="text" placeholder="notification body">
				<input id="notificationIconUrl"	type="url" placeholder="notification icon url">
				<button id="sendNotificationButton">Send Notification!</button>
			</form>
		</div>


		<h1>Introducción</h1>
		<p>
			a grosso modo:
			<ol>
				<li>
					<strong>step 1 : Ask user consent to show notifications</strong>
				</li>
				<li>
					<strong>step 2 : Susbcribe to push notification</strong>
					this will create an endpoint that has to be sent to the push server
				</li>
				<li>
					<strong>step 3 : Send the subscription to the push server</strong>
					
				</li>
				<li>
					<strong>step 4 : Ask the push server for a notification</strong>
					in production you don't ask for notifications, The push server decide itself when to send them
				</li>
			</ol>
		</p>
		<h1>Explicación:</h1>
		<ol>
			<li>
				debemos subscribir al usuario, para que cada vez que pase algo, el servidor sepa a
				quién enviar las notificaciones. El cliente debe mantener una comunicación con el
				servidor, así el usuario cierre la página, para hacer esto, utilizamos la API
				Service Workers, para ejecutar un proceso en el background.
			</li>

			<li>
				Los serviceWorker solo funcionan bajo el protocolo https, o utilizando http pero en
				localhost; para poder hacer pruebas de este proyecto desde otros dispositivos
				teniendo el servidor en el localhost, vamos a configurar el http express server para
				que sea un httpS server:

				<ol>
					<li>
						Creación de una clave privada de 2048 bits con el algoritmo AES-256: $
						openssl genrsa -aes256 -out my_cert.pem 2048
					</li>
					<li>
						Creación del CSR correspondiente: $ openssl req -new -key my_cert.pem -out
						my_cert.csr
					</li>
					<li>
						Firma del CSR generado en el paso anterior: $ openssl x509 -req -days 365
						-in my_cert.csr -signkey my_cert.pem -out my_cert.crt
					</li>
					<li>
						Para desencriptar la clave privada RSA: $ openssl rsa -in my_cert.pem -out
						my_cert.key
					</li>
					<li>
						Cuando tengas los archivos de los certificados digitales, cópialos en la
						carpeta raíz de tu proyecto Node.js, la misma que contiene el archivo
						index.ts
					</li>
				</ol>
			</li>
			<li>
				Necesitamos los módulos fs y https:
				<ul>
					<li>npm install fs --save</li>
					<li>npm install https --save</li>
				</ul>
			</li>

			<li>
				para poder probar el service worker desde otro pc, necesitamos abrir Google Chrome
				ignorando los errores del certificado auto firmado que generamos: google-chrome
				--user-data-dir=/tmp/foo --ignore-certificate-errors
				--unsafely-treat-insecure-origin-as-secure=https://192.168.0.7:3000/
			</li>
		</ol>

		<h3>fuentes:</h3>
		<ol>
			<li>
				<span style="color: red">
					Start a https express server with self signed certificate:
				</span>
				https://programarivm.com/pon-en-marcha-un-servidor-https-en-node-js-con-express
			</li>
			<li>
				<span style="color: red">
				Deploy on Heroku
				</span>
				https://medium.com/developer-rants/deploying-typescript-node-js-applications-to-heroku-81dd75424ce0
			</li>

			<li>
				<span style="color: red">
				CDN de getMessaging y getToken, entender que hay 2 formas de obtener
				el endpoint para que nuestro app server envíe notificaciones.
				Una es a través de la API Notification Push del navegador, y otra
				a través de el SDK de firebase que está instalado por CDNs en este proyecto
				</span>
				https://www.itwonders-web.com/blog/push-notification-using-firebase-demo-tutorial
			</li>


		</ol>
		<script type="module">
			// Import the functions you need from the SDKs you need
			import { initializeApp } from "https://www.gstatic.com/firebasejs/9.2.0/firebase-app.js";
			import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.2.0/firebase-analytics.js";
			import { getMessaging, getToken } from "https://www.gstatic.com/firebasejs/9.2.0/firebase-messaging.js";

			var registrationToken = "";
			// -> import { getMessaging, getToken } from "../node_modules/firebase/messaging";
			// TODO: Add SDKs for Firebase products that you want to use
			// https://firebase.google.com/docs/web/setup#available-libraries
		  
			// Your web app's Firebase configuration
			// For Firebase JS SDK v7.20.0 and later, measurementId is optional
			const firebaseConfig = {
			  apiKey: "AIzaSyAK7stROuMarsBPjWlm-Yqp98X_SWl-4y8",
			  authDomain: "notification-demo-22494.firebaseapp.com",
			  projectId: "notification-demo-22494",
			  storageBucket: "notification-demo-22494.appspot.com",
			  /**
			   * Este messagingSenderId se utiliza para subscribir al usuario
			   * así el usuario sabe quién es el remitente de las notificaciones.
			   * También lo utiliza nuestro appServer para envíarselo al pushService
			   * y así el pushService sabe a nombre de qué remitente debe enviar la 
			   * notificación al usuario con x token registration. Por eso debe coincidir.
			  */
			  messagingSenderId: "615368318220",
			  appId: "1:615368318220:web:95f27a345817e3b904fd29",
			  measurementId: "G-STM7NF0FJ9"
			};
		  
			// Initialize Firebase
			const app = initializeApp(firebaseConfig);
			const analytics = getAnalytics(app);

			// Get registration token. Initially this makes a network call, once retrieved
			// subsequent calls to getToken will return from cache.
			const messaging = getMessaging();
			getToken(messaging, { vapidKey: 'BGY7pD6kC5Nag-QDYRggWTu9nDQSG_APUSCwmaTPtpkTS32O6ueDg9aMAF1fLJaMOwfK_u05fBjyxI3rtx8peiA' }).then((currentToken) => {
			if (currentToken) {
				// Send the token to your server and update the UI if necessary
				console.log("your FCM token is: ", currentToken);
				document.getElementById("FCMregistrationToken").value = currentToken;
			} else {
				// Show permission request UI
				console.log('No registration token available. Request permission to generate one.');
				// ...
			}
			}).catch((err) => {
			console.log('An error occurred while retrieving token. ', err);
			// ...
			});

		  </script>
		<script src="./main.js"></script>
	</body>
</html>
